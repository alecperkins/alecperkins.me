// Generated by CoffeeScript 1.4.0
(function() {
  var NOAT, _addTextAnnotations, _closeTag, _openTag;

  _openTag = function(t) {
    var attrs, k, v, _ref;
    attrs = '';
    _ref = t.attrs;
    for (k in _ref) {
      v = _ref[k];
      attrs += " " + k + "=\"" + v + "\"";
    }
    return "<" + t.tag + attrs + ">";
  };

  _closeTag = function(t) {
    return "</" + t.tag + ">";
  };

  _addTextAnnotations = function(text, annotations) {
    /*
        Private: insert the specified annotation tags into the given text at the
        correct positions, avoiding overlapping tags (invalid HTML).
    
        The text is broken into segments, bounded by the start and end points of all of
        the annotations. It is then reassembled, with opening and closing tags for
        annotations inserted between the segments. Tags are closed and reopened as
        needed to prevent overlap.
    
        For example, given:
    
            text = "Duis mollis, est non commodo luctus, nisi erat porttitor ligula, \
            eget lacinia odio sem nec elit."
    
            annotations = [{
                'type': 'emphasis',
                'start': 5,
                'end': 30,
            },{
                'type': 'strong',
                'start': 20,
                'end': 50,
            }]
    
        Simply inserting the tags at the given `start` and `end` positions would
        result in invalid HTML:
    
            "Duis <em>mollis, est non<strong> commodo l</em>uctus, nisi erat por\
            </strong>ttitor ligula, eget lacinia odio sem nec elit."
    
        The correct output is:
    
            "Duis <em>mollis, est non<strong> commodo l</strong></em><strong>\
            uctus, nisi erat por</strong>ttitor ligula, eget lacinia odio sem nec\
             elit."
    
        Note that the `</strong>` tag before the `strong`'s `end`, to allow the
        `emphasis` annotation to be closed without overlapping the `<strong>`. The
        `strong` annotation is then reopened with a `<strong>` and then closed at
        its actual end.
    
    
        * content     - str content of the block
        * annotations - list of annotations (MAY be empty)
            * type  - str type of the annotation
            * start - int starting point of the annotation
            * end   - int ending point of the annotation
            * attrs - (optional) a dict of tag attributes
    
        Returns a unicode containing the markup of the text content, with
        annotations inserted.
    */

    var a, annotation_index_by_end, annotation_index_by_start, bound, end, i, k, o_tag, open_tags, output, seg_text, segment_boundaries, segments, start, t, tags_to_close, tags_to_open, tags_to_reopen, v, _i, _j, _k, _l, _len, _len1, _len2, _len3, _name, _name1, _ref, _ref1, _ref2;
    annotation_index_by_start = {};
    annotation_index_by_end = {};
    for (_i = 0, _len = annotations.length; _i < _len; _i++) {
      a = annotations[_i];
      if ((_ref = annotation_index_by_start[_name = a['start']]) == null) {
        annotation_index_by_start[_name] = [];
      }
      annotation_index_by_start[a['start']].push(a);
      if (a['start'] !== a['end']) {
        if ((_ref1 = annotation_index_by_end[_name1 = a['end']]) == null) {
          annotation_index_by_end[_name1] = [];
        }
        annotation_index_by_end[a['end']].push(a);
      }
    }
    segment_boundaries = [];
    for (k in annotation_index_by_start) {
      v = annotation_index_by_start[k];
      segment_boundaries.push(parseInt(k));
    }
    for (k in annotation_index_by_end) {
      v = annotation_index_by_end[k];
      segment_boundaries.push(parseInt(k));
    }
    segment_boundaries.sort(function(a, b) {
      return a - b;
    });
    if (segment_boundaries.length === 0 || segment_boundaries[0] !== 0) {
      segment_boundaries.unshift(0);
    }
    if (segment_boundaries[segment_boundaries.length - 1] !== text.length) {
      segment_boundaries.push(text.length);
    }
    segments = [];
    _ref2 = segment_boundaries.slice(0, -1);
    for (i in _ref2) {
      bound = _ref2[i];
      start = bound;
      end = segment_boundaries[parseInt(i) + 1];
      if (start !== end) {
        segments.push(text.substring(start, end));
      }
    }
    output = '';
    open_tags = [];
    i = 0;
    for (_j = 0, _len1 = segments.length; _j < _len1; _j++) {
      seg_text = segments[_j];
      tags_to_open = annotation_index_by_start[i] || [];
      tags_to_close = annotation_index_by_end[i] || [];
      tags_to_reopen = [];
      for (_k = 0, _len2 = tags_to_close.length; _k < _len2; _k++) {
        t = tags_to_close[_k];
        while (open_tags.length > 0 && t['tag'] !== open_tags[open_tags.length - 1]['tag']) {
          o_tag = open_tags.pop();
          output += _closeTag(o_tag);
          tags_to_reopen.push(o_tag);
        }
        output += _closeTag(t);
        open_tags.pop();
        while (tags_to_reopen.length > 0) {
          o_tag = tags_to_reopen.pop();
          output += _openTag(o_tag);
          open_tags.push(o_tag);
        }
      }
      for (_l = 0, _len3 = tags_to_open.length; _l < _len3; _l++) {
        t = tags_to_open[_l];
        output += _openTag(t);
        if (t['start'] !== t['end']) {
          open_tags.push(t);
        } else {
          output += _closeTag(t);
        }
      }
      output += seg_text;
      i += seg_text.length;
    }
    while (open_tags.length > 0) {
      o_tag = open_tags.pop();
      output += _closeTag(o_tag);
    }
    return output;
  };

  NOAT = (function() {

    function NOAT(text) {
      if (text.length === 0) {
        throw new Error('text length must be greater than zero');
      }
      this.text = text;
      this.annotations = [];
      this._markup = null;
    }

    NOAT.prototype.add = function(tag, start, end_or_attrs, attrs) {
      var end;
      if (attrs == null) {
        attrs = {};
      }
      if (arguments.length > 4) {
        throw new Error("add() takes 3 or 4 arguments (" + arguments.length + " given)");
      }
      if (typeof end_or_attrs !== 'number') {
        end = start;
        attrs = end_or_attrs;
      } else {
        end = end_or_attrs;
      }
      start = parseInt(start);
      end = parseInt(end);
      this._validateRange(start, end);
      this.annotations.push({
        tag: tag,
        start: start,
        end: end,
        attrs: attrs
      });
      return this._markup = null;
    };

    NOAT.prototype._applyAnnotations = function() {
      return this._markup = _addTextAnnotations(this.text, this.annotations);
    };

    NOAT.prototype.toString = function() {
      if (!(this._markup != null)) {
        this._applyAnnotations();
      }
      return this._markup;
    };

    NOAT.prototype._validateRange = function(start, end) {
      if (start > end) {
        throw new Error("start (" + start + ") must be <= end (" + end + ")");
      }
      if (start < 0) {
        throw new Error("start (" + start + ") must be >= 0");
      }
      if (end > this.text.length) {
        throw new Error("end (" + end + ") must be <= length of text (" + this.text.length + ")");
      }
    };

    return NOAT;

  })();

  window.NOAT = NOAT;

}).call(this);
